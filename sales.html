// 更新筛选器选项（实现多级联动）
function updateFilterOptions() {
    if (!currentProductType) return;
    
    const config = filterConfigs[currentProductType] || [];
    const data = productData[currentProductType] || [];
    
    // 根据所有当前筛选条件过滤数据
    let filteredData = data;
    
    // 应用所有筛选条件
    for (const [field, value] of Object.entries(currentFilters)) {
        filteredData = filteredData.filter(item => item[field] === value);
    }
    
    // 为每个筛选器更新选项
    config.forEach(filter => {
        // 跳过相位类型字段（我们已经用按钮处理了）
        if (filter.field === currentPhaseTypeField) return;
        
        const select = document.getElementById(filter.id);
        if (!select) return;
        
        const field = filter.field;
        const currentValue = select.value;
        
        // 获取该字段在过滤后数据中的可能值
        const availableValues = [...new Set(filteredData.map(item => item[field]))].filter(v => v);
        availableValues.sort();
        
        // 保存当前选中的值（如果在新数据中还存在）
        const shouldKeepCurrentValue = currentValue && availableValues.includes(currentValue);
        
        // 更新选项
        select.innerHTML = '<option value="">请选择</option>';
        availableValues.forEach(value => {
            const option = document.createElement('option');
            option.value = value;
            option.textContent = value;
            
            // 如果这个值应该被选中，则选中
            if (shouldKeepCurrentValue && value === currentValue) {
                option.selected = true;
            }
            
            select.appendChild(option);
        });
        
        // 如果当前选中的值在过滤后不可用，清空它
        if (currentValue && !availableValues.includes(currentValue)) {
            delete currentFilters[field];
            select.value = "";
        }
    });
}
